# acpl/configs/data/graphs.yaml
# -----------------------------------------------------------------------------
# Graph generation config (Hydra-friendly).
# Selects the graph *family* and the parameters used by acpl/data/graphs.py
# to build an undirected simple graph (plus optional coordinates & PE).
#
# Minimal usage:
#   family: line
#   N: 64
#   seed: 1234
#
# CLI overrides examples:
#   python scripts/train.py +data=@data/graphs.yaml data.family=grid data.grid.Lx=10 data.grid.Ly=8
#   python scripts/eval.py  +data=@data/graphs.yaml data.family=ws_grid data.ws_grid.beta=0.35 data.ws_grid.torus=true
#   python scripts/eval.py  +data=@data/graphs.yaml data.family=ws      data.ws.beta=0.35 data.ws.k=8
# -----------------------------------------------------------------------------

# ------------------------------- Master switches ------------------------------

# Pick one: line | cycle | grid | cube | regular | er | ws | ws_grid
family: line

# Reproducibility seed for generators that use randomness (ER/WS/regular ties)
seed: 1234

# Sanity & cleaning
coalesce: true         # merge duplicate undirected edges & remove self-loops
directed: false        # keep false for standard DTQW experiments
self_loops: false      # do NOT add self-loops in the graph (coins already mix locally)

# ------------------------------ Shared size knobs -----------------------------

# Used by single-size families (line/cycle/regular/er default number of nodes)
N: 64

# -------------------------- Family-specific parameter blocks ------------------

line:
  # Path graph on {0,…,N-1}
  N: ${..N}

cycle:
  # Cycle graph on {0,…,N-1}
  N: ${..N}

grid:
  # Rectangular grid (no wrap unless ws.torus=true). Total nodes: Lx * Ly.
  Lx: 8
  Ly: 8
  # Optional helper for coords; leave true for easy visualization
  make_coords: true    # produce integer (x,y) and normalized (x/Lx, y/Ly)

cube:
  # Hypercube Q_d with N = 2^d nodes. If 'd' is set, top-level N is ignored.
  d: 6                 # d=6 -> N=64
  emit_bitstrings: true  # include binary coordinates for features/viz

regular:
  # d-regular simple graph on N nodes. Retries until success.
  N: ${..N}
  d: 3
  max_retries: 50

er:
  # Erdős–Rényi G(N, p). Edges coalesced, no self-loops.
  N: ${..N}
  p: 0.05              # edge probability in [0,1]
  keep_connected: true
  max_tries: 2000

ws:
  # Choose which WS generator to use:
  #   ring -> watts_strogatz_graph(N,k,beta)
  #   grid -> watts_strogatz_grid_graph(Lx,Ly,kx,ky,beta,torus,degree_preserving)
  variant: grid   # ring | grid

  # ---- ring (1D) ----
  N: ${..N}
  k: 8
  beta: 0.2
  keep_connected: true

  # ---- grid (2D) ----
  Lx: 10
  Ly: 10
  kx: 1
  ky: 1
  beta_grid: 0.2          # if your loader expects ws.beta, keep using ws.beta; otherwise use this
  torus: false
  degree_preserving: true
  keep_connected_grid: false


ws_grid:
  # Watts–Strogatz-like small-world on a 2D grid (local neighbors then rewire).
  Lx: 10
  Ly: 10
  kx: 1
  ky: 1
  beta: 0.2
  torus: false
  sanitize: true
  keep_connected: false
  max_tries: 200


# ------------------------- Positional encodings (PE) --------------------------
# These settings control optional position/spectral features creation. Your
# model can ignore them safely; they are provided for convenience/consistency.

posenc:
  # none | laplacian | coords | hybrid
  # - none:   no extra PE (degree-only features are still allowed by your features builder)
  # - laplacian: top-k Laplacian eigenvectors with deterministic sign fix
  # - coords: grid/hypercube coordinates only (if available)
  # - hybrid: concatenate coords (if available) with LapPE
  kind: laplacian

  # Laplacian specifics (used if kind in {laplacian, hybrid})
  k: 16                 # number of eigenvectors (small nontrivial)
  norm: "sym"           # "sym" (I - D^{-1/2} A D^{-1/2}) or "comb" (D - A)
  sign_fix: "max"       # "max" -> flip each eigvec so argmax|phi| is positive
  standardize: true     # zero-mean/unit-std per PE channel

  # Coordinate specifics (used if kind in {coords, hybrid} and coords exist)
  coords_norm: true     # normalize coordinates to [0,1] range

# ------------------------------- Robustness knobs -----------------------------
# These are read by robustness tasks/evals; harmless to leave at defaults.

robustness:
  # Static edge phases (disorder). When enabled at eval, downstream pipeline draws
  # phases φ~Uniform[-phi_max,phi_max] (radians) and folds them into the shift/coins.
  static_edge_phases:
    enabled: false
    phi_max: 0.0       # e.g., 0.3 ~ moderate disorder

  # Coin dephasing noise (per step). If enabled, downstream code may apply a small
  # diagonal phase jitter to local coins during rollout for robustness sweeps.
  coin_dephasing:
    enabled: false
    sigma: 0.0         # stddev in radians

  # Missing-edge rate for drop-edge stress tests at eval time
  drop_edge:
    enabled: false
    p_drop: 0.0        # fraction of edges removed uniformly at random

# ------------------------------ Features & coords -----------------------------
# Controls for the convenience outputs from the generator. If the runner ignores
# them, nothing breaks.

features:
  degree: true         # include normalized degree in X
  # For grids/cubes, emit coordinates/bitstrings if available
  include_coords: true
  include_bitstrings: true

coords:
  # If true and family supports it, return both integer coords and normalized coords
  export: true

# ------------------------------- Validation guards ----------------------------
# Checked by your runner/util if desired (no-op if unused).

validate:
  allow_isolated: false   # assert min degree >= 1 after construction if false
  max_degree: null        # e.g., 16 -> assert deg(u) <= 16 for all u
  must_be_connected: null # null | true | false (null = do not check)

# --------------------------------- Caching ------------------------------------
# Optional cache hints for expensive PE on repeated sizes/topologies.
cache:
  enable: true
  # Cache key suggestion: (family, params, N/Lx/Ly/d, seed-independent topology key)
  dir: ".acpl_cache/graphs"   # runner may use this to persist LapPE/coords per (family,size)

# --------------------------------- Notes --------------------------------------
# • graphs.py returns: edge_index (2,E), degrees (N,), coords (N,2 or None),
#   and arc_slices (N+1,) to index per-node arc ranges.
# • For line/cycle/grid/cube we also emit normalized coordinates; ER/regular/WS
#   fall back to simple 1D coords (i/(N-1), 0) unless your features builder overrides.
# • coalesce=true guarantees a simple undirected graph view, matching the DTQW simulator.
# • All extra blocks (posenc/robustness/features/coords/cache) are strictly optional,
#   designed to be safely ignored by older runners.
